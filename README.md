# スッキリわかるJava入門 第4版

## 参考リンク
- [とりあえず Docker で Java を動かしたい](https://qiita.com/siruku6/items/bb47727770e88b1efc7c)

## Chapter1 基礎的な文法・仕様など

## Chapter2 クラス
- クラスの設計・仕様、インスタンスの生成、コンストラクタによる定義
- クラスの集約（aggregation, "has-a"の関係）

## Chapter3 継承
- クラスの継承（inheritance, "is-a"の関係）

## Chapter4 抽象クラス・抽象メソッド
- 処理内容を決定できない詳細未定のメソッドは、"abstract" を付けて抽象メソッドとする
- 抽象メソッドを1つでも含むクラスは、"abstract" を付けて抽象クラスにする必要がある
- 抽象クラスはインスタンス化できない
- 抽象クラスと抽象メソッドを活用して、継承の材料である親クラスを準備しておけば、予期しないインスタンス化やオーバーライド忘れの懸念が無くなるメリットあり

## Chapter5 インターフェース
- 特別扱いの抽象クラス（インターフェース）
- 抽象クラスのうち、抽象メソッドしか持たないものをインターフェースと呼称する
- 複数のインターフェースを親とした多重継承が可能
- インターフェースを親とする子クラスを定義する際には "implements" で宣言する
- インターフェースを親とする子インターフェースを定義する際には "extends" で宣言する

## Chapter6 ポリモーフィズム（多態性）
- インスタンスをあいまいにとらえる
  - 継承により is-a の関係が成立しているなら、インスタンスを親クラス型の変数に代入出来る
  - 親クラス型の変数への代入は、そのインスタンスをあいまいにとらえる事を意味する
- 箱の型と中身の型の役割
  - どのメソッドを利用できるかは、インスタンスの箱の型で決まる
  - メソッドがどう動くかは、インスタンスの中身の型で決まる
- 捉え方の変更
  - キャスト演算子を用いれば、厳密な方への強制代入が出来る
  - 不正な代入はコンパイル時にエラー（ClassCastException）
- 多様性
  - 厳密には異なる複数のインスタンスを同一視して、親クラス型の配列にまとめて扱う事ができる
  - 同様に、親クラス型の引数や戻り値を利用して、厳密には異なる対象をまとめて処理できる
  - 同一視して取り扱っても、個々のインスタンスは各クラスにおける定義に従い、異なる動作を行う

## Chapter7 カプセル化（隠蔽）

### Java のメンバへのアクセス修飾子

- private : アクセス許可は自身のクラスのみ
- package private : 自分と同じパッケージに属するクラスのみ。何も記述しない場合はこれが適用
- protected : 自分と同じパッケージか、自分を継承した子クラスのみ
- public : すべてのクラス

設定の定石としては、フィールドは全て private、メソッドは全て public にして、必要に応じて微調整していく

### Java のクラスへのアクセス修飾子

- package private : 自分と同じパッケージに属するクラスのみ。何も記述しない場合はこれが適用
- public : すべてのクラス

public クラスはファイル内に1つのみしか書けないが、package private クラスは 1つのファイルにいくつ書いても問題無し。public クラスを書いたファイルに併記するケースが多い。package private クラスだけを独立したファイルに書くのはあまり一般的ではない。

### getter と setter メソッド
- private フィールドにアクセスするために getter や setter メソッドを設定するのが定石。
- setter メソッドにおいては、異常値の入力を防ぐための妥当性チェックを組み込むのが定石。

## Chapter8 代表的な JavaAPI群

### Object クラス
- Java において、すべてのクラスは Object クラスの子孫
- すべてのインスタンスは Object 型に代入できる
- すべてのクラスは Object から toString() や equals() を継承している
- 自分で作成したくらすについては、必要に応じて toString() や equals() をオーバーライドして使う

### 静的メンバ
- フィールドやメソッドに static を付けて宣言すると静的メンバとなる
- インスタンスそれぞれにではなく、クラスそのものに実体が準備される
- クラス名、インスタンス名のどちらからでも静的メンバにはアクセス可能
- インスタンス生成しなくても静的メンバは利用可能
- 静的メンバは、自分が作成したクラスに付けるよりも、JavaAPI を通して利用する場面が多い

## Chapter9 文字列と日付の扱い

### 文字列の操作

- String クラスに備わっているメソッドを使って、さまざまな文字列操作を行うことができる。
- 複数回の文字列連結には、`+` 演算子ではなく StringBuilder クラスを用いる。
- 正規表現を使うと、さまざまなパターンマッチングを表現できる。

### 日付と時間の扱い (伝統的な API)

- 日時情報は基本的に `java.util.Date` 型で扱う。
- 「年月日時分秒」の6つの `int` 値から Date インスタンスを得るには Calendar クラスを使う。
- Date インスタンスの内容を任意の書式で文字列に整形したい場合は、SimpleDateFormat クラスを使う。


### 日付と時間の扱い (Time API)

- `java.time` パッケージの API を用いると、より便利かつ安全に日付や時刻を扱うことができる。
- 厳密な時刻を格納するには、Instant クラスや ZonedDateTime クラスを用いる。
- 日常的に利用する日時情報の格納には、LocalDateTime クラスが適している。
- あいまいな日時を表現するために、LocalDate や YearMonth など複数のクラスが準備されている。
- Duration クラスや Period クラスには、時間の間の間隔を格納できる。
- TimeAPI では多くのクラスで `new` が禁止されており、静的メソッド `now()` や `of()` を用いてインスタンスを取得する。

## Chapter10 配列とコレクション

- 主要なコレクションとして List（リスト）、Set（集合）、Map（辞書） の3種類があり、目的に応じて適切なものを選択して活用する（図16-19）。
- コレクションの容量（格納できる要素の数）は、必要に応じて自動的に増加する。
- イテレータを用いて要素を1つずつ取り出すことができる。
- コレクションには基本型の値は格納できないため、必要に応じてラッパークラスを活用する。
- Hash系コレクションに独自に開発したクラスを格納する場合、 `equals()` や `hashCode()` をオーバーライドする必要がある。

## Chapter11 例外

### エラー
- エラーには、文法エラー、実行時エラー、論理エラーの3種類がある。
- 例外処理を行うと、実行時エラーに対処できる。

### 例外の種類
- APIには、さまざまな例外状況を表す例外クラスが用意されている。
- 例外クラスは、Error系、Exception系、RuntimeException系に大別できる。
- 例外クラスを継承してオリジナルの例外クラスを定義できる。

### 例外処理
- try-catch文を使用すると、tryブロック内で例外が発生したときにcatchブロックに処理が移る。
- Exception系の例外が起こる可能性がある場合は、try-catch文が必須である。
- 後片付けの処理は、状況に関わらず必ず実行される`finally`ブロックに記述する。
- try-with-resources文を利用すると、後片付け処理の記述が不要になる。
- スロー宣言で、例外の処理を呼び出し元に委ねることができる。
- throw文で、開発者自ら例外を発生させることができる。（上記のスロー宣言とは全く違う概念なので注意）
